import { useRef, useState, useEffect, useCallback } from 'react';\nimport type { Tool } from '../types/index';\nimport type {\n  SearchOptions,\n  SearchResult,\n  ToolMetadata,\n  AdvancedSearchEngine,\n} from '../utils/searchUtils';\nimport type {\n  IndexWorkerMessage,\n  IndexWorkerResponse,\n} from '../workers/searchIndexWorker';\n\nexport interface SearchPerformanceMetrics {\n  indexBuildTime?: number;\n  lastSearchTime?: number;\n  toolsPerSecond?: number;\n  averageTimePerTool?: number;\n  indexedToolCount?: number;\n}\n\nexport interface UseOptimizedSearchReturn {\n  // Search functionality\n  search: (query: string, options?: Partial<SearchOptions>) => Promise<SearchResult<Tool>[]>;\n  \n  // Index management\n  buildIndex: (tools: Tool[], metadata?: Map<string, ToolMetadata>) => Promise<void>;\n  addTool: (tool: Tool, metadata?: ToolMetadata) => Promise<void>;\n  removeTool: (toolId: string) => Promise<void>;\n  updateMetadata: (toolId: string, metadata: ToolMetadata) => Promise<void>;\n  \n  // State\n  isIndexing: boolean;\n  isIndexBuilt: boolean;\n  isSearching: boolean;\n  indexingProgress: number;\n  searchError: string | null;\n  \n  // Performance metrics\n  performanceMetrics: SearchPerformanceMetrics;\n  \n  // Fallback search (for when worker is not available)\n  fallbackSearch: (query: string, tools: Tool[]) => Tool[];\n}\n\nconst WORKER_TIMEOUT = 30000; // 30 seconds\nconst MIN_TOOLS_FOR_WORKER = 50; // Use worker only for larger datasets\n\nexport function useOptimizedSearch(): UseOptimizedSearchReturn {\n  const workerRef = useRef<Worker | null>(null);\n  const searchEngineRef = useRef<AdvancedSearchEngine | null>(null);\n  const messageIdRef = useRef(0);\n  const pendingOperationsRef = useRef<Map<string, {\n    resolve: (value: any) => void;\n    reject: (error: Error) => void;\n    timeout: NodeJS.Timeout;\n  }>>(new Map());\n  \n  const [isIndexing, setIsIndexing] = useState(false);\n  const [isIndexBuilt, setIsIndexBuilt] = useState(false);\n  const [isSearching, setIsSearching] = useState(false);\n  const [indexingProgress, setIndexingProgress] = useState(0);\n  const [searchError, setSearchError] = useState<string | null>(null);\n  const [performanceMetrics, setPerformanceMetrics] = useState<SearchPerformanceMetrics>({});\n  const [useWorker, setUseWorker] = useState(false);\n  \n  // Initialize worker and search engine\n  useEffect(() => {\n    // Check if web workers are supported\n    if (typeof Worker !== 'undefined') {\n      try {\n        // Create worker\n        workerRef.current = new Worker(\n          new URL('../workers/searchIndexWorker.ts', import.meta.url),\n          { type: 'module' }\n        );\n        \n        // Handle worker messages\n        workerRef.current.onmessage = handleWorkerMessage;\n        \n        // Handle worker errors\n        workerRef.current.onerror = (error) => {\n          console.warn('Search worker error:', error);\n          setSearchError('Search worker encountered an error');\n          setUseWorker(false);\n        };\n        \n        setUseWorker(true);\n      } catch (error) {\n        console.warn('Failed to create search worker:', error);\n        setUseWorker(false);\n      }\n    }\n    \n    // Initialize fallback search engine\n    if (!useWorker) {\n      import('../utils/searchUtils').then(({ AdvancedSearchEngine }) => {\n        searchEngineRef.current = new AdvancedSearchEngine();\n      });\n    }\n    \n    // Cleanup\n    return () => {\n      if (workerRef.current) {\n        workerRef.current.terminate();\n      }\n      \n      // Clear pending operations\n      pendingOperationsRef.current.forEach(({ reject, timeout }) => {\n        clearTimeout(timeout);\n        reject(new Error('Component unmounted'));\n      });\n      pendingOperationsRef.current.clear();\n    };\n  }, []);\n  \n  const handleWorkerMessage = useCallback((event: MessageEvent<IndexWorkerResponse>) => {\n    const { type, payload, id } = event.data;\n    \n    switch (type) {\n      case 'INDEX_BUILT':\n        if (payload.isComplete) {\n          setIsIndexing(false);\n          setIsIndexBuilt(true);\n          setIndexingProgress(100);\n          setPerformanceMetrics(prev => ({\n            ...prev,\n            indexBuildTime: payload.duration,\n            toolsPerSecond: payload.performance?.toolsPerSecond,\n            averageTimePerTool: payload.performance?.averageTimePerTool,\n            indexedToolCount: payload.indexedCount,\n          }));\n          \n          if (id) {\n            resolvePendingOperation(id, payload);\n          }\n        } else {\n          setIndexingProgress(payload.progress);\n        }\n        break;\n        \n      case 'SEARCH_RESULTS':\n        setIsSearching(false);\n        setPerformanceMetrics(prev => ({\n          ...prev,\n          lastSearchTime: payload.searchTime,\n        }));\n        \n        if (id) {\n          resolvePendingOperation(id, payload.results);\n        }\n        break;\n        \n      case 'TOOL_ADDED':\n      case 'TOOL_REMOVED':\n      case 'METADATA_UPDATED':\n        if (id) {\n          resolvePendingOperation(id, payload);\n        }\n        break;\n        \n      case 'ERROR':\n        setIsIndexing(false);\n        setIsSearching(false);\n        setSearchError(payload.message);\n        \n        if (id) {\n          rejectPendingOperation(id, new Error(payload.message));\n        }\n        break;\n    }\n  }, []);\n  \n  const sendWorkerMessage = useCallback(<T>(\n    message: Omit<IndexWorkerMessage, 'id'>\n  ): Promise<T> => {\n    return new Promise((resolve, reject) => {\n      if (!workerRef.current || !useWorker) {\n        reject(new Error('Worker not available'));\n        return;\n      }\n      \n      const messageId = (++messageIdRef.current).toString();\n      \n      // Set up timeout\n      const timeout = setTimeout(() => {\n        rejectPendingOperation(messageId, new Error('Operation timed out'));\n      }, WORKER_TIMEOUT);\n      \n      // Store pending operation\n      pendingOperationsRef.current.set(messageId, {\n        resolve,\n        reject,\n        timeout,\n      });\n      \n      // Send message\n      workerRef.current.postMessage({\n        ...message,\n        id: messageId,\n      });\n    });\n  }, [useWorker]);\n  \n  const resolvePendingOperation = useCallback((id: string, result: any) => {\n    const operation = pendingOperationsRef.current.get(id);\n    if (operation) {\n      clearTimeout(operation.timeout);\n      operation.resolve(result);\n      pendingOperationsRef.current.delete(id);\n    }\n  }, []);\n  \n  const rejectPendingOperation = useCallback((id: string, error: Error) => {\n    const operation = pendingOperationsRef.current.get(id);\n    if (operation) {\n      clearTimeout(operation.timeout);\n      operation.reject(error);\n      pendingOperationsRef.current.delete(id);\n    }\n  }, []);\n  \n  const buildIndex = useCallback(async (\n    tools: Tool[],\n    metadata?: Map<string, ToolMetadata>\n  ): Promise<void> => {\n    setSearchError(null);\n    setIndexingProgress(0);\n    \n    // Decide whether to use worker based on dataset size\n    const shouldUseWorker = useWorker && tools.length >= MIN_TOOLS_FOR_WORKER;\n    \n    if (shouldUseWorker) {\n      setIsIndexing(true);\n      \n      const metadataArray = metadata ? Array.from(metadata.entries()) : undefined;\n      \n      await sendWorkerMessage({\n        type: 'BUILD_INDEX',\n        payload: {\n          tools,\n          metadata: metadataArray,\n        },\n      });\n    } else {\n      // Use synchronous fallback\n      setIsIndexing(true);\n      \n      if (!searchEngineRef.current) {\n        const { AdvancedSearchEngine } = await import('../utils/searchUtils');\n        searchEngineRef.current = new AdvancedSearchEngine();\n      }\n      \n      const startTime = performance.now();\n      \n      tools.forEach((tool, index) => {\n        const toolMetadata = metadata?.get(tool.id);\n        searchEngineRef.current!.indexTool(tool, toolMetadata);\n        \n        // Update progress\n        const progress = ((index + 1) / tools.length) * 100;\n        setIndexingProgress(progress);\n      });\n      \n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      \n      setPerformanceMetrics({\n        indexBuildTime: duration,\n        toolsPerSecond: (tools.length / duration) * 1000,\n        averageTimePerTool: duration / tools.length,\n        indexedToolCount: tools.length,\n      });\n      \n      setIsIndexing(false);\n      setIsIndexBuilt(true);\n      setIndexingProgress(100);\n    }\n  }, [useWorker, sendWorkerMessage]);\n  \n  const search = useCallback(async (\n    query: string,\n    options: Partial<SearchOptions> = {}\n  ): Promise<SearchResult<Tool>[]> => {\n    if (!query.trim()) {\n      return [];\n    }\n    \n    setSearchError(null);\n    \n    if (useWorker && isIndexBuilt) {\n      setIsSearching(true);\n      \n      try {\n        const results = await sendWorkerMessage<SearchResult<Tool>[]>({\n          type: 'SEARCH',\n          payload: {\n            query,\n            options: {\n              maxResults: options.maxResults,\n              fuzzy: options.fuzzy,\n              highlightMatches: options.highlightMatches,\n            },\n          },\n        });\n        \n        return results;\n      } catch (error) {\n        console.warn('Worker search failed, falling back to sync search:', error);\n        setIsSearching(false);\n        return fallbackSearch(query, []);\n      }\n    } else if (searchEngineRef.current) {\n      setIsSearching(true);\n      \n      const searchOptions: SearchOptions = {\n        query,\n        fields: [\n          { name: 'name', weight: 1.0 },\n          { name: 'description', weight: 0.8 },\n          { name: 'category', weight: 0.6 },\n          { name: 'tags', weight: 0.5 },\n        ],\n        fuzzy: options.fuzzy ?? true,\n        highlightMatches: options.highlightMatches ?? true,\n        maxResults: options.maxResults ?? 50,\n      };\n      \n      const startTime = performance.now();\n      const results = searchEngineRef.current.search(searchOptions);\n      const endTime = performance.now();\n      \n      setPerformanceMetrics(prev => ({\n        ...prev,\n        lastSearchTime: endTime - startTime,\n      }));\n      \n      setIsSearching(false);\n      return results;\n    }\n    \n    return [];\n  }, [useWorker, isIndexBuilt, sendWorkerMessage]);\n  \n  const addTool = useCallback(async (\n    tool: Tool,\n    metadata?: ToolMetadata\n  ): Promise<void> => {\n    if (useWorker && isIndexBuilt) {\n      await sendWorkerMessage({\n        type: 'ADD_TOOL',\n        payload: { tool, metadata },\n      });\n    } else if (searchEngineRef.current) {\n      searchEngineRef.current.indexTool(tool, metadata);\n    }\n  }, [useWorker, isIndexBuilt, sendWorkerMessage]);\n  \n  const removeTool = useCallback(async (toolId: string): Promise<void> => {\n    if (useWorker && isIndexBuilt) {\n      await sendWorkerMessage({\n        type: 'REMOVE_TOOL',\n        payload: { toolId },\n      });\n    } else if (searchEngineRef.current) {\n      searchEngineRef.current.removeTool(toolId);\n    }\n  }, [useWorker, isIndexBuilt, sendWorkerMessage]);\n  \n  const updateMetadata = useCallback(async (\n    toolId: string,\n    metadata: ToolMetadata\n  ): Promise<void> => {\n    if (useWorker && isIndexBuilt) {\n      await sendWorkerMessage({\n        type: 'UPDATE_METADATA',\n        payload: { toolId, metadata },\n      });\n    } else if (searchEngineRef.current) {\n      searchEngineRef.current.updateMetadata(toolId, metadata);\n    }\n  }, [useWorker, isIndexBuilt, sendWorkerMessage]);\n  \n  const fallbackSearch = useCallback((query: string, tools: Tool[]): Tool[] => {\n    if (!query.trim()) return [];\n    \n    const queryLower = query.toLowerCase();\n    \n    return tools\n      .filter(tool => {\n        const searchableText = `${tool.name} ${tool.description} ${tool.category} ${(tool.tags || []).join(' ')}`.toLowerCase();\n        return searchableText.includes(queryLower);\n      })\n      .slice(0, 50); // Limit results\n  }, []);\n  \n  return {\n    search,\n    buildIndex,\n    addTool,\n    removeTool,\n    updateMetadata,\n    isIndexing,\n    isIndexBuilt,\n    isSearching,\n    indexingProgress,\n    searchError,\n    performanceMetrics,\n    fallbackSearch,\n  };\n}\n\nexport default useOptimizedSearch;"