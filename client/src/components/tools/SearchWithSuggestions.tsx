import React, { useState, useEffect, useCallback, useRef } from 'react';
import {
  Box,
  TextField,
  Autocomplete,
  Paper,
  ListItem,
  ListItemIcon,
  ListItemText,
  IconButton,
  Typography,
  Chip,
  Card,
  CardContent,
  List,
  Divider,
  InputAdornment,
  Popper,
  ClickAwayListener,
} from '@mui/material';\nimport {\n  Search as SearchIcon,\n  Clear as ClearIcon,\n  History as HistoryIcon,\n  Build as BuildIcon,\n  Category as CategoryIcon,\n  Label as LabelIcon,\n  TrendingUp as TrendingIcon,\n  Tune as TuneIcon,\n} from '@mui/icons-material';\nimport { useDebouncedValue } from '../../hooks/useDebouncedValue';\nimport type { Tool } from '../../types/index';\nimport type { ToolMetadata } from '../../utils/searchUtils';\n\nexport interface SearchSuggestion {\n  type: 'tool' | 'category' | 'tag' | 'history' | 'popular';\n  value: string;\n  label: string;\n  icon: React.ReactNode;\n  description?: string;\n  count?: number;\n}\n\nexport interface SearchWithSuggestionsProps {\n  onSearch: (query: string) => void;\n  onSuggestionSelect?: (suggestion: SearchSuggestion) => void;\n  tools: Tool[];\n  metadata?: Map<string, ToolMetadata>;\n  placeholder?: string;\n  maxSuggestions?: number;\n  showSearchHistory?: boolean;\n  searchHistory?: string[];\n  onSearchHistoryUpdate?: (history: string[]) => void;\n}\n\nconst STORAGE_KEY = 'toolVault_searchHistory';\nconst MAX_HISTORY_ITEMS = 10;\n\nexport const SearchWithSuggestions: React.FC<SearchWithSuggestionsProps> = ({\n  onSearch,\n  onSuggestionSelect,\n  tools,\n  metadata = new Map(),\n  placeholder = 'Search tools, categories, or tags...',\n  maxSuggestions = 8,\n  showSearchHistory = true,\n  searchHistory: externalSearchHistory,\n  onSearchHistoryUpdate,\n}) => {\n  const [query, setQuery] = useState('');\n  const [suggestions, setSuggestions] = useState<SearchSuggestion[]>([]);\n  const [internalSearchHistory, setInternalSearchHistory] = useState<string[]>([]);\n  const [showSuggestions, setShowSuggestions] = useState(false);\n  const [popularSearches] = useState<string[]>([\n    'GIS tools',\n    'text analysis',\n    'data visualization',\n    'machine learning',\n    'geospatial',\n  ]);\n  \n  const inputRef = useRef<HTMLInputElement>(null);\n  const debouncedQuery = useDebouncedValue(query, 300);\n  \n  // Use external search history if provided, otherwise use internal\n  const searchHistory = externalSearchHistory || internalSearchHistory;\n  const updateSearchHistory = onSearchHistoryUpdate || setInternalSearchHistory;\n\n  // Load search history from localStorage on mount\n  useEffect(() => {\n    if (!externalSearchHistory && showSearchHistory) {\n      try {\n        const stored = localStorage.getItem(STORAGE_KEY);\n        if (stored) {\n          setInternalSearchHistory(JSON.parse(stored));\n        }\n      } catch (error) {\n        console.warn('Failed to load search history:', error);\n      }\n    }\n  }, [externalSearchHistory, showSearchHistory]);\n\n  // Generate suggestions based on query\n  useEffect(() => {\n    if (debouncedQuery.length >= 2) {\n      generateSuggestions(debouncedQuery);\n    } else if (debouncedQuery.length === 0) {\n      generateEmptyStateSuggestions();\n    } else {\n      setSuggestions([]);\n    }\n  }, [debouncedQuery, tools, metadata]);\n\n  const generateSuggestions = useCallback((searchQuery: string) => {\n    const queryLower = searchQuery.toLowerCase();\n    const newSuggestions: SearchSuggestion[] = [];\n\n    // Tool name suggestions (with relevance scoring)\n    const toolMatches = tools\n      .filter(tool => tool.name.toLowerCase().includes(queryLower))\n      .map(tool => {\n        const toolMeta = metadata.get(tool.id);\n        const executions = toolMeta?.usage?.executions || 0;\n        return {\n          tool,\n          relevance: tool.name.toLowerCase().startsWith(queryLower) ? 100 : 50,\n          popularity: executions,\n        };\n      })\n      .sort((a, b) => {\n        // Sort by relevance first, then popularity\n        if (a.relevance !== b.relevance) {\n          return b.relevance - a.relevance;\n        }\n        return b.popularity - a.popularity;\n      })\n      .slice(0, 3)\n      .map(({ tool, popularity }) => ({\n        type: 'tool' as const,\n        value: tool.name,\n        label: tool.name,\n        icon: <BuildIcon />,\n        description: tool.description.length > 60 \n          ? `${tool.description.substring(0, 60)}...` \n          : tool.description,\n        count: popularity > 0 ? popularity : undefined,\n      }));\n\n    // Category suggestions\n    const categories = [...new Set(tools.map(tool => tool.category).filter(Boolean))]\n      .filter(category => category!.toLowerCase().includes(queryLower))\n      .map(category => {\n        const count = tools.filter(tool => tool.category === category).length;\n        return {\n          category: category!,\n          count,\n          relevance: category!.toLowerCase().startsWith(queryLower) ? 100 : 50,\n        };\n      })\n      .sort((a, b) => {\n        if (a.relevance !== b.relevance) {\n          return b.relevance - a.relevance;\n        }\n        return b.count - a.count;\n      })\n      .slice(0, 2)\n      .map(({ category, count }) => ({\n        type: 'category' as const,\n        value: category,\n        label: `Category: ${category}`,\n        icon: <CategoryIcon />,\n        count,\n      }));\n\n    // Tag suggestions\n    const allTags = tools.flatMap(tool => tool.tags || []);\n    const tagCounts = allTags.reduce((acc, tag) => {\n      acc[tag] = (acc[tag] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n    \n    const tagMatches = Object.entries(tagCounts)\n      .filter(([tag]) => tag.toLowerCase().includes(queryLower))\n      .map(([tag, count]) => ({\n        tag,\n        count,\n        relevance: tag.toLowerCase().startsWith(queryLower) ? 100 : 50,\n      }))\n      .sort((a, b) => {\n        if (a.relevance !== b.relevance) {\n          return b.relevance - a.relevance;\n        }\n        return b.count - a.count;\n      })\n      .slice(0, 3)\n      .map(({ tag, count }) => ({\n        type: 'tag' as const,\n        value: tag,\n        label: `Tag: ${tag}`,\n        icon: <LabelIcon />,\n        count,\n      }));\n\n    newSuggestions.push(...toolMatches, ...categories, ...tagMatches);\n    setSuggestions(newSuggestions.slice(0, maxSuggestions));\n  }, [tools, metadata, maxSuggestions]);\n\n  const generateEmptyStateSuggestions = useCallback(() => {\n    const newSuggestions: SearchSuggestion[] = [];\n\n    // Recent searches\n    if (showSearchHistory && searchHistory.length > 0) {\n      const historyItems = searchHistory.slice(0, 3).map(item => ({\n        type: 'history' as const,\n        value: item,\n        label: item,\n        icon: <HistoryIcon />,\n      }));\n      newSuggestions.push(...historyItems);\n    }\n\n    // Popular searches\n    const popularItems = popularSearches.slice(0, 3).map(item => ({\n      type: 'popular' as const,\n      value: item,\n      label: item,\n      icon: <TrendingIcon />,\n      description: 'Popular search',\n    }));\n    newSuggestions.push(...popularItems);\n\n    setSuggestions(newSuggestions.slice(0, maxSuggestions));\n  }, [searchHistory, showSearchHistory, popularSearches, maxSuggestions]);\n\n  const handleSearch = useCallback((searchQuery: string) => {\n    if (searchQuery.trim()) {\n      // Update search history\n      const newHistory = [\n        searchQuery,\n        ...searchHistory.filter(item => item !== searchQuery)\n      ].slice(0, MAX_HISTORY_ITEMS);\n      \n      updateSearchHistory(newHistory);\n      \n      // Save to localStorage if using internal history\n      if (!externalSearchHistory && showSearchHistory) {\n        try {\n          localStorage.setItem(STORAGE_KEY, JSON.stringify(newHistory));\n        } catch (error) {\n          console.warn('Failed to save search history:', error);\n        }\n      }\n      \n      onSearch(searchQuery);\n      setShowSuggestions(false);\n    }\n  }, [searchHistory, updateSearchHistory, externalSearchHistory, showSearchHistory, onSearch]);\n\n  const handleSuggestionClick = useCallback((suggestion: SearchSuggestion) => {\n    setQuery(suggestion.value);\n    handleSearch(suggestion.value);\n    \n    if (onSuggestionSelect) {\n      onSuggestionSelect(suggestion);\n    }\n  }, [handleSearch, onSuggestionSelect]);\n\n  const handleInputChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {\n    setQuery(event.target.value);\n  }, []);\n\n  const handleInputFocus = useCallback(() => {\n    setShowSuggestions(true);\n    if (query.length === 0) {\n      generateEmptyStateSuggestions();\n    }\n  }, [query.length, generateEmptyStateSuggestions]);\n\n  const handleKeyDown = useCallback((event: React.KeyboardEvent<HTMLInputElement>) => {\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      handleSearch(query);\n    } else if (event.key === 'Escape') {\n      setQuery('');\n      setShowSuggestions(false);\n      inputRef.current?.blur();\n    }\n  }, [query, handleSearch]);\n\n  const handleClear = useCallback(() => {\n    setQuery('');\n    setSuggestions([]);\n    setShowSuggestions(false);\n    inputRef.current?.focus();\n  }, []);\n\n  const handleClickAway = useCallback(() => {\n    setShowSuggestions(false);\n  }, []);\n\n  const getSuggestionIcon = (suggestion: SearchSuggestion) => {\n    switch (suggestion.type) {\n      case 'tool':\n        return <BuildIcon color=\"primary\" />;\n      case 'category':\n        return <CategoryIcon color=\"secondary\" />;\n      case 'tag':\n        return <LabelIcon color=\"info\" />;\n      case 'history':\n        return <HistoryIcon color=\"action\" />;\n      case 'popular':\n        return <TrendingIcon color=\"success\" />;\n      default:\n        return suggestion.icon;\n    }\n  };\n\n  const renderSuggestion = (suggestion: SearchSuggestion, index: number) => (\n    <ListItem\n      key={`${suggestion.type}-${suggestion.value}-${index}`}\n      button\n      onClick={() => handleSuggestionClick(suggestion)}\n      sx={{\n        py: 1,\n        '&:hover': {\n          backgroundColor: 'action.hover',\n        },\n      }}\n    >\n      <ListItemIcon sx={{ minWidth: 36 }}>\n        {getSuggestionIcon(suggestion)}\n      </ListItemIcon>\n      <ListItemText\n        primary={\n          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>\n            <Typography variant=\"body2\">{suggestion.label}</Typography>\n            {suggestion.count && (\n              <Chip\n                size=\"small\"\n                label={suggestion.count.toLocaleString()}\n                variant=\"outlined\"\n                sx={{ height: 20, fontSize: '0.7rem' }}\n              />\n            )}\n          </Box>\n        }\n        secondary={suggestion.description}\n        secondaryTypographyProps={{\n          variant: 'caption',\n          color: 'text.secondary',\n          sx: { mt: 0.5 }\n        }}\n      />\n    </ListItem>\n  );\n\n  return (\n    <ClickAwayListener onClickAway={handleClickAway}>\n      <Box sx={{ position: 'relative', width: '100%' }}>\n        <TextField\n          ref={inputRef}\n          fullWidth\n          value={query}\n          onChange={handleInputChange}\n          onFocus={handleInputFocus}\n          onKeyDown={handleKeyDown}\n          placeholder={placeholder}\n          variant=\"outlined\"\n          size=\"medium\"\n          InputProps={{\n            startAdornment: (\n              <InputAdornment position=\"start\">\n                <SearchIcon color=\"action\" />\n              </InputAdornment>\n            ),\n            endAdornment: query && (\n              <InputAdornment position=\"end\">\n                <IconButton\n                  onClick={handleClear}\n                  edge=\"end\"\n                  size=\"small\"\n                  aria-label=\"Clear search\"\n                >\n                  <ClearIcon />\n                </IconButton>\n              </InputAdornment>\n            ),\n          }}\n          sx={{\n            '& .MuiOutlinedInput-root': {\n              backgroundColor: 'background.paper',\n            },\n          }}\n        />\n        \n        {/* Suggestions Dropdown */}\n        {showSuggestions && suggestions.length > 0 && (\n          <Paper\n            sx={{\n              position: 'absolute',\n              top: '100%',\n              left: 0,\n              right: 0,\n              zIndex: 1300,\n              maxHeight: 400,\n              overflow: 'auto',\n              mt: 0.5,\n              boxShadow: 3,\n            }}\n          >\n            <List dense sx={{ py: 0 }}>\n              {query.length === 0 && searchHistory.length > 0 && (\n                <>\n                  <ListItem sx={{ py: 0.5, px: 2 }}>\n                    <Typography variant=\"caption\" color=\"text.secondary\" sx={{ fontWeight: 600 }}>\n                      Recent searches\n                    </Typography>\n                  </ListItem>\n                  <Divider />\n                </>\n              )}\n              \n              {suggestions.map((suggestion, index) => {\n                // Add divider between recent searches and popular searches\n                if (query.length === 0 && suggestion.type === 'popular' && index > 0 && suggestions[index - 1].type === 'history') {\n                  return (\n                    <React.Fragment key={`divider-${index}`}>\n                      <Divider />\n                      <ListItem sx={{ py: 0.5, px: 2 }}>\n                        <Typography variant=\"caption\" color=\"text.secondary\" sx={{ fontWeight: 600 }}>\n                          Popular searches\n                        </Typography>\n                      </ListItem>\n                      {renderSuggestion(suggestion, index)}\n                    </React.Fragment>\n                  );\n                }\n                return renderSuggestion(suggestion, index);\n              })}\n            </List>\n          </Paper>\n        )}\n      </Box>\n    </ClickAwayListener>\n  );\n};\n\nexport default SearchWithSuggestions;"